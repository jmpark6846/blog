### 페이징 처리
JPA 에서는 페이징 처리를 위해 Page와 Pageable 사용
예) Page<Product> findByName(String name, Pageable pageable)
리턴타입으로 Page, 매개변수로 Pageable


### JPQL @Query 어노테이션 으로 쿼리 직접 작성하기
* 튜닝된 쿼리를 실행시킬때 주로 사용한다.

* 예)
"""@Query("select p.name, p.price, p.stock from Product as p where p.name = :name")
List<Object[]> findByName(@Param("name") String name);"""

* 문자열을 입력하기 때문에 컴파일 시점에는 에러를 잡지 못하고 런타임 에러가 발생할 수 있다. (= 개발환경에서는 문제가 없지만 실행환경에서 문제 발생할 수 있음)
* 이 문제 해결을 위해 나온 것이 QueryDSL



### QueryDSL
* 문자열이 아니라 코드로 쿼리를 작성
* 동적 쿼리 생성, 문자열이 아닌 코드로 쿼리를 생성하기 떄문에 오류가 날 확률이 적고 작성하기도 편리하다.
* QuerydslPredicateExecutor, QuerydslRepositorySupport 두 클래스를 활용하여 더 편하게 사용.


# 연관 관계 매핑

### 일대일 단방향, 양방향 매핑 
* @JoinColumn: 매핑할 왜래키 설정. name 속성으로 원하는 칼럼명을 지정하는 것이 좋다. 설정하지 않으면 엔티티를 매핑하는 중간 테이블이 생겨 관리포인트가 늘어나 좋지 않다.
* 즉시로딩(Eager Loading): 엔티티를 조회할 떄 연관된 엔티티도 함께 조회하는 것

* 데이터베이스에서 테이블간 연관관계를 갖고 있으면 한쪽 테이블이 외래키를 가지는 구조로 됨(‘주인’ 개념)
* JPA 에서도 이를 반영하여 엔티티가 양방향으로 매핑하되 한쪽에게만 외래키를 주도록한다. (mappedBy)
  * mappedBy: 어떤 객체가 주인인지 표시. 

* 양방향 관계 설정 시 ToString 에서 순환참조 발생. 비슷한 이유로 꼭 필요한 경우가 아니라면 대체로 단방향으로 연관관계를 설정한다. 혹은 문제 발생하지 않도록 적절한 조치 필요
예) ToString.exclude로 ToString에서 제외 설정 

### 다대일 양방향 매핑
* 일대일과 마찬가지로 RDBMS 형식을 사용하기 위해 한쪽으로 외래키 관리를 위임

* 상황에 따라 다르겠지만, 일대다 보다 다대일로 관계를 설정하는 것이 더 깔끔해보인다. 일대다 단방향 매핑의 경우 관계를 설정하려면 ‘일’인 엔티티에서 리스트에 추가하는 형태로 관계를 설정하는데, 실제로는 ‘다’인 엔티티에서 외래키를 update 하는 쿼리를 추가로 더 날리게된다. 

### 영속성 전이(cascade)
* 엔티티 영속성 상태를 변경할때 그 엔티티와 연관된 엔티티의 영속성에도 영향을 미쳐서 영속성 상태 변경하는 것


